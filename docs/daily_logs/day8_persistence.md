# Day 8 — Persistence Layer: Complete Implementation
**Date: 24 February 2026**

---

## Goal

Design and implement the full persistence layer from first principles — deriving every file format decision and boundary from constraints before writing code.

---

## Why Both Files Are Needed

| File | Purpose | Without it |
|------|---------|-----------|
| `snapshot.bin` | Full card state at checkpoint | Must replay entire log from the beginning on every startup |
| `review.log` | Events since last snapshot | Lose all reviews that happened after the last checkpoint |

Together: fast startup (snapshot) + zero data loss (log fills the gap).

---

## What Must Be Persisted Per Card

All scheduling state fields are required:

```cpp
CardId id
TopicId topicId
UserId userId          // ownership
double easeFactor      // controls interval growth
int interval           // current spacing
int repetitions        // determines which interval rule applies
Date nextReviewDate    // when the card is next due
```

Dropping any scheduling field resets card progress to defaults on restart. The SM-2 algorithm cannot continue correctly without the full state.

---

## Snapshot File Format

```
[card_count : int]
[userId][cardId][topicId][easeFactor][interval][repetitions][nextReviewDate]
[userId][cardId][topicId][easeFactor][interval][repetitions][nextReviewDate]
...
```

Count is written first so the reader knows exactly how many records to expect.

---

## Log Record Format

```
[userId][cardId][rating][timestamp][CRC32]
```

No count header — records are appended one at a time over an unknown duration. Reading stops at EOF or the first CRC mismatch.

---

## CRC32 Checksum Reasoning

- A crash mid-write leaves a partial record at the end of the log
- On recovery, CRC is recalculated from the 4 data fields and compared against the stored value
- CRC is computed only over data fields — never over the CRC field itself (circular)
- Replay stops at first mismatch — recovery is deterministic and safe

---

## Crash Safety — Snapshot Write Strategy

```
1. Write full state to snapshot.tmp
2. fsync(snapshot.tmp)
3. rename(snapshot.tmp → snapshot)   ← atomic
4. fsync directory
5. Delete review log
```

Writing directly to the snapshot and crashing mid-write would corrupt it permanently. The temp + rename approach guarantees the live snapshot is always valid.

---

## Architectural Boundaries

- Persistence layer lives in a separate folder — isolated from scheduling logic
- Scheduler exposes `get_users()` — persistence reads data without touching internals
- On load, persistence calls `scheduler.create_user()` and `scheduler.add_card()` — scheduler owns all mutations
- Timestamp is generated by the caller and passed into `append_log` — function is a pure writer, fully testable

---

## Methods Implemented

### `save_snapshot`
- Counts total cards across all users before opening the file
- Writes count as header, then writes each card's full field set in binary
- Uses `snapshot_path` from constructor, checks `is_open()` before writing

### `load_snapshot`
- Reads count from header, loops exactly that many times
- Reads each field in the exact same order as `save_snapshot`
- Calls `scheduler.create_user()` then `scheduler.add_card()` — `create_user` is idempotent

### `append_log`
- Opens log in append + binary mode
- Fills `LogRecord` struct with all data fields
- Calculates CRC32 over data portion only (excluding the `crc` field)
- Writes entire struct in one call, then flushes

### `replay_log`
- Opens log in binary read mode
- Loops reading one `LogRecord` at a time until EOF
- Recalculates CRC, breaks on mismatch — handles partial writes from crashes
- Calls `scheduler.review_complete()` for each valid record

---

## Architecture Status After Today

| Layer | Status |
|-------|--------|
| Engine Layer | Complete |
| Scheduling Logic | Complete |
| Service Layer | Complete |
| Persistence Layer | Complete |
| gRPC Contract | In Progress |
| Go API Layer | In Progress |
| Integration Testing | Not Started |

---

## Next Session

- Wire persistence into `main.cpp` — startup loads snapshot then replays log
- Call `append_log` after each `review_complete`
- Trigger `save_snapshot` every N reviews
- Verify crash recovery end to end

---

## Reflection

Today was not about writing a lot of code. It was about deriving each decision from constraints before touching the keyboard. Every file format choice, every field included, every boundary drawn was reasoned through from first principles.

This is the kind of thinking that distinguishes production backend work from tutorial projects.